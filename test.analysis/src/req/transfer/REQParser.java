/* Generated By:JJTree&JavaCC: Do not edit this line. REQParser.java */
/*
 * This software is licensed under the terms of the ISC License.
 * (ISCL http://www.opensource.org/licenses/isc-license.txt
 * It is functionally equivalent to the 2-clause BSD licence,
 * with language "made unnecessary by the Berne convention" removed).
 *
 * Copyright (c) 2011-2013 Mike Norman
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
 * RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE
 * USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 ******************************************************************************/
package req.transfer;
//javase imports
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.io.ByteArrayInputStream;

public class REQParser/*@bgen(jjtree)*/implements REQParserTreeConstants, REQParserConstants {/*@bgen(jjtree)*/
  protected JJTREQParserState jjtree = new JJTREQParserState();List < Object > list = new ArrayList < Object > ();
  List < String > inArgs = new ArrayList < String > ();
  List < String > outArgs = new ArrayList < String > ();

  public REQParser(String in)
  {
    this (new ByteArrayInputStream(in.getBytes()));
  }

  public void addInArg(String s) {
        inArgs.add(s);
  }
  public void addOutArg(String s) {
        outArgs.add(s);
  }
  public void addAllInArg( List < String > s) {
        inArgs.addAll(s);
  }
  public void addAllOutArg( List < String > s) {
        outArgs.addAll(s);
  }

  final public Object parse() throws ParseException {
 /*@bgen(jjtree) parse */
  SimpleNode jjtn000 = new SimpleNode(JJTPARSE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String s;
  StringBuilder sb = new StringBuilder();
    try {
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case REQ:
        case RSP:
        case BUILTIN:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case RPAREN:
        case LBRACE:
        case RBRACE:
        case LBRACKET:
        case RBRACKET:
        case COMMA:
        case DOT:
        case ASSIGN:
        case BANG:
        case HOOK:
        case COLON:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case PLUS:
          ;
          break;
        default:
          break label_1;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case REQ:
        case RSP:
        case BUILTIN:
          s = reqParam();
    sb.append(s);
          break;
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case RPAREN:
        case LBRACE:
        case RBRACE:
        case LBRACKET:
        case RBRACKET:
        case COMMA:
        case DOT:
        case ASSIGN:
        case BANG:
        case HOOK:
        case COLON:
        case EQ:
        case LE:
        case GE:
        case NE:
        case SC_OR:
        case SC_AND:
        case PLUS:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            t = jj_consume_token(IDENTIFIER);
            break;
          case DOT:
            t = jj_consume_token(DOT);
            break;
          case LPAREN:
            t = jj_consume_token(LPAREN);
            break;
          case RPAREN:
            t = jj_consume_token(RPAREN);
            break;
          case LBRACE:
            t = jj_consume_token(LBRACE);
            break;
          case RBRACE:
            t = jj_consume_token(RBRACE);
            break;
          case LBRACKET:
            t = jj_consume_token(LBRACKET);
            break;
          case RBRACKET:
            t = jj_consume_token(RBRACKET);
            break;
          case STRING_LITERAL:
            t = jj_consume_token(STRING_LITERAL);
            break;
          case BANG:
            t = jj_consume_token(BANG);
            break;
          case LE:
            t = jj_consume_token(LE);
            break;
          case GE:
            t = jj_consume_token(GE);
            break;
          case NE:
            t = jj_consume_token(NE);
            break;
          case HOOK:
            t = jj_consume_token(HOOK);
            break;
          case EQ:
            t = jj_consume_token(EQ);
            break;
          case ASSIGN:
            t = jj_consume_token(ASSIGN);
            break;
          case SC_OR:
            t = jj_consume_token(SC_OR);
            break;
          case SC_AND:
            t = jj_consume_token(SC_AND);
            break;
          case PLUS:
            t = jj_consume_token(PLUS);
            break;
          case COLON:
            t = jj_consume_token(COLON);
            break;
          case COMMA:
            t = jj_consume_token(COMMA);
            break;
          default:
            jj_consume_token(-1);
            throw new ParseException();
          }
        sb.append(t.image);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return sb.toString();}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String reqParam() throws ParseException {
 /*@bgen(jjtree) reqParam */
  SimpleNode jjtn000 = new SimpleNode(JJTREQPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String s;
  StringBuilder sb = new StringBuilder();
  boolean isBuilt = false;
    try {
      if (jj_2_1(4)) {
        t = jj_consume_token(REQ);
        sb.append("request().getAllMembers()");
      } else if (jj_2_2(4)) {
        t = jj_consume_token(RSP);
        sb.append("response().getAllMembers()");
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case BUILTIN:
          t = jj_consume_token(BUILTIN);
        isBuilt = true;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACKET:
          ;
          break;
        default:
          break label_2;
        }
        s = param();
        if(isBuilt) {
                String tmp = s.replace("\u005c"","");
                        if(inArgs.contains(tmp)) {
                                sb.append("inArgMap()");
                        }else if(outArgs.contains(tmp)) {
                                sb.append("outArgMap()");
                        }else {
                                sb.append("varMap()");
                        }
                        isBuilt = false;
        }
        sb.append(".get(").append(s).append(")");
      }
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      {if (true) return sb.toString();}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  final public String param() throws ParseException {
 /*@bgen(jjtree) param */
  SimpleNode jjtn000 = new SimpleNode(JJTPARAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);Token t;
  String s;
  StringBuilder sb = new StringBuilder();
    try {
      jj_consume_token(LBRACKET);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REQ:
      case RSP:
      case BUILTIN:
        s = reqParam();
        break;
      case INTEGER_LITERAL:
      case STRING_LITERAL:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
          t = jj_consume_token(STRING_LITERAL);
        s = t.image;
          break;
        case INTEGER_LITERAL:
          t = jj_consume_token(INTEGER_LITERAL);
        s = t.image;
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_consume_token(-1);
        throw new ParseException();
      }
    sb.append(s);
      label_3:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING_LITERAL:
        case PLUS:
        case 69:
        case 70:
          ;
          break;
        default:
          break label_3;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 69:
          t = jj_consume_token(69);
      sb.append(t.image);
          break;
        case 70:
          t = jj_consume_token(70);
      sb.append(t.image);
          break;
        case PLUS:
          t = jj_consume_token(PLUS);
      sb.append(t.image);
          break;
        case STRING_LITERAL:
          t = jj_consume_token(STRING_LITERAL);
      sb.append(t.image);
          break;
        default:
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      jj_consume_token(RBRACKET);
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    {if (true) return sb.toString();}
    } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      {if (true) throw (RuntimeException)jjte000;}
    }
    if (jjte000 instanceof ParseException) {
      {if (true) throw (ParseException)jjte000;}
    }
    {if (true) throw (Error)jjte000;}
    } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
    }
    throw new Error("Missing return statement in function");
  }

  private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
  }

  private boolean jj_3_2() {
    if (jj_scan_token(RSP)) return true;
    return false;
  }

  private boolean jj_3_1() {
    if (jj_scan_token(REQ)) return true;
    return false;
  }

  /** Generated Token Manager. */
  public REQParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;

  /** Constructor with InputStream. */
  public REQParser(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public REQParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new REQParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  /** Constructor. */
  public REQParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new REQParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  /** Constructor with generated Token Manager. */
  public REQParser(REQParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
  }

  /** Reinitialise. */
  public void ReInit(REQParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jjtree.reset();
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      return token;
    }
    token = oldToken;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  /** Generate ParseException. */
  public ParseException generateParseException() {
    Token errortok = token.next;
    int line = errortok.beginLine, column = errortok.beginColumn;
    String mess = (errortok.kind == 0) ? tokenImage[0] : errortok.image;
    return new ParseException("Parse error at line " + line + ", column " + column + ".  Encountered: " + mess);
  }

  /** Enable tracing. */
  final public void enable_tracing() {
  }

  /** Disable tracing. */
  final public void disable_tracing() {
  }

}
